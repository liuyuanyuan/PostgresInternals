# 10 基础备份 & 基于时间点的(Point-in-Time)恢复

在线数据库备份可以大致分为两类：逻辑备份和物理备份。虽然它们都有优点和缺点，但逻辑备份有一个缺点：花费太多时间进行性能测试。特别是，它需要花费大量时间来进行大型数据库的备份，甚至需要更多时间来从备份数据中还原此类数据库。相反，物理备份可以在较短的时间内备份和还原大型数据库，因此它在实际系统中是非常重要和有用的功能。

在PostgreSQL中，在线物理完全备份自版本8.0开始可用，并且正在运行的整个数据库集簇的快照（即物理备份数据）被称为**基础备份**。

**时间点恢复（Point-in-Time Recovery ，简称为PITR)**，自版本8.0开始提供，该功能可使用由[连续归档（continuous archiving）](http://www.interdb.jp/pg/pgsql09.html#_9.10.)创建的*基本备份*和*归档日志*，将数据库集簇还原到任何时间点。例如，即使您犯了严重错误（例如，截断（truncating）所有表），此功能也能确保数据库可以恢复到犯错之前的时间点。 

本章将介绍以下主题：

- 什么是基础备份
- PITR 如何运作
- 什么是 timelineId
- 什么是时间轴（timeline）历史数据 

在版本7.4或更早版本中，PostgreSQL仅支持逻辑备份（逻辑全备和逻辑部分备份，以及数据导出）。

## 10.1. 基础备份

首先，使用低级命令进行基本备份的标准过程如下所示：

- (1) 发送 *[pg_start_backup](http://www.postgresql.org/docs/current/static/functions-admin.html#FUNCTIONS-ADMIN-BACKUP)* 命令
- (2) 使用要用的归档命令对数据库集群拍摄快照
- (3) 发送 *[pg_stop_backup](http://www.postgresql.org/docs/current/static/functions-admin.html#FUNCTIONS-ADMIN-BACKUP)* 命令

对于数据库系统管理员来说，此简单过程易于使用，因为它不需要特殊工具，而是需要诸如复制命令或类似归档工具之类的通用工具来创建基本备份。此外，在此过程中，不需要表锁，所有用户都可以发出查询而不受备份操作的影响。与其他主要的开源RDBMS相比，这些是很大的优势。

进行基本备份的更简单方法是使用 *[pg_basebackup](http://www.postgresql.org/docs/current/static/app-pgbasebackup.html)*实用程序，然而，它在内部发送这些低级别的命令。

**图 10.1. 做一次基础备份**

![Fig. 10.1. Making a base backup.](http://www.interdb.jp/pg/img/fig-10-01.png)![img]()

由于这两个命令显然是理解PITR的关键点之一，因此我们将在以下小节中进行探讨。

 *pg_start_backup* and *pg_stop_backup* 名义定义在 [src/backend/access/transam/xlogfuncs.c](https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xlogfuncs.c) 中。

### 10.1.1. pg_start_backup

*pg_start_backup*为基础备份做预备。如 [第9.8节](http://www.interdb.jp/pg/pgsql09.html#_9.8.)中所述，恢复过程从REDO点开始，因此*pg_start_backup*必须执行检查点才能显式创建一个REDO点指向进行基本备份的开始。此外，它的检查点的位置必须保存在pg_control以外的文件中，因为常规的检查点在备份过程中可能会执行多次。因此，*pg_start_backup*执行以下四个操作：

1. 强制进入full-page wirte mode。
2. 切换到当前的WAL段文件（在版本8.4或更高版本）。
3. 执行 checkpoint。
4. 创建一个backup_label 文件 – 该文件，创建于基础目录的顶层，包含有关基础备份本身的基本信息，例如此检查点的检查点位置。

第三和第四操作是此命令的核心；执行第一和第二操作以更可靠地恢复一个数据库集簇。

一个 *backup_label* 文件包含以下6项 (版本11或更新版本中是7项)：

- CHECKPOINT LOCATION – 这是该命令创建的检查点已记录的LSN位置。
- START WAL LOCATION – **不**将其与PITR一起使用，而与流复制一起使用，这在[第 11 章](http://www.interdb.jp/pg/pgsql11.html).中进行了介绍。之所以命名为“ START WAL LOCATION”，是因为在复制模式下的备用服务器在初始启动时仅读取一次该值。 
- BACKUP METHOD – 这是进行基本备份的方法 ( *'pg_start_backup'* 或者 *'pg_basebackup'*.)
- BACKUP FROM – 这是现实该备份是来源于主端还是备端。
- START TIME – 这是 *pg_start_backup* 执行后到时间戳。
- LABEL – 这是 *pg_start_backup* 时指定的标签。 
- START TIMELINE – 这是备份开始的时间线（timeline）。这是用于完整性检查，已在版本11中引入。

 *backup_label*

以下显示了版本9.6中backup_label文件的实际示例：

```
postgres> cat /usr/local/pgsql/data/backup_label
START WAL LOCATION: 0/9000028 (file 000000010000000000000009)
CHECKPOINT LOCATION: 0/9000060
BACKUP METHOD: pg_start_backup
BACKUP FROM: master
START TIME: 2020-1-11 11:45:19 GMT
LABEL: Weekly Backup
```

可以想象，当您使用此基础备份来恢复数据库时，PostgreSQL从backup_label文件中取出“ CHECKPOINT LOCATION”，以从相应的归档日志中读取检查点记录，然后，从其记录中获取REDO点，并开始恢复进程。 （详细信息将在下一节中介绍。）

### 10.1.2. pg_stop_backup

*pg_stop_backup* 执行以下五个操作来完成备份。

1. 如果已被*pg_start_backup*强制更改，则重置为*non-full-page writes* 模式。
2. 编写备份端的XLOG记录。
3. 切换WAL段文件。
4. 创建备份历史记录文件–该文件包含backup_label文件的内容以及*pg_stop_backup*已执行的时间戳。
5. 删除 backup_label 文件 – 从基本备份中恢复需要使用backup_label文件，并且一旦复制了该文件，它在原始数据库集簇中就不需要了。

*备份历史文件的命名方法* 展示如下。

```
{WAL segment}.{offset value at the time the base backup was started}.backup
```

## 10.2. 时间点恢复是如何工作的

图10.2 显示了PITR的基本概念。处于PITR模式的PostgreSQL，从*pg_start_backup*创建的REDO点到你要恢复的点，在基本备份上重演存档日志的中的WAL数据。在PostgreSQL中，要恢复的点称为**恢复目标（recovery target）**。

**图 10.2. PITR的基础概念**

![Fig. 10.2. Basic concept of PITR.](http://www.interdb.jp/pg/img/fig-10-02.png)![img]()

这里是PITR工作原理的描述。假设您在2020年1月11日格林尼治标准（GTM）时间12:05犯了一个错误。您应该删除数据库集簇，并使用之前的基础备份来还原出新的集簇。然后，创建一个recovery.conf文件，并在您犯错时（本例中为12:05 GTM）的文件中设置参数*recovery_target_time*的时间。 recovery.conf文件如下所示：

```
# Place archive logs under /mnt/server/archivedir directory.
restore_command = 'cp /mnt/server/archivedir/%f %p'
recovery_target_time = "2020-1-11 12:05 GMT"
```

当 PostgreSQL 启动，如果数据库集簇中有*recovery.conf* 和*backup_label*，它将进入PITR模式。

PITR进程几乎与 [第 9 章](http://www.interdb.jp/pg/pgsql09.html#_9.8.)中描述的正常恢复过程相同。它们之间的唯一区别是以下两点：

1. 从哪里读取 WAL段/归档日志 ?
   - 正常恢复模式 – 从基础目录下的 pg_xlog 子目录 (在版本 10 或更新版本，是 pg_wal 子目录)
   - PITR 模式 – 从配置参数archive_command中设置的归档目录中。
2. 从哪里读取检查点位置?
   - 正常恢复模式 – 从一个 *pg_control 文件*。
   - PITR 模式 – 从一个 *backup_label 文件*。

PITR过程的概述如下：

- (1) In order to find the REDO point, PostgreSQL reads the value of ‘*CHECKPOINT LOCATION*’ from the backup_label file with the internal function *read_backup_label*.
- (2) PostgreSQL reads some values of parameters from the recovery.conf; in this example, *restore_command* and *recovery_target_time*.
- (3) PostgreSQL starts replaying WAL data from the REDO point, which can be easily obtained from the value of ‘*CHECKPOINT LOCATION*’. The WAL data are read from archive logs which are copied from the archival area to a temporary area by executing the command written in the parameter *resotere_command*. (The copied log files in the temporary area are removed after using.)
  In this example, PostgreSQL reads and replays WAL data from the REDO point to the one before the timestamp ‘2020-1-11 12:05:00’ because the parameter *recovery_target_time* is set to this timestamp. If a recovery target is not set to the recovery.conf, PostgreSQL will replay until end of archiving logs.
- (4) When the recovery process completes, a **timeline history file**, such as ‘00000002.history’, is created in the pg_xlog subdirectory (in version 10 or later, pg_wal subdirectory); if archiving log feature is enabled, same named file is also created in the archival directory. The contents and role of this file are described in the following sections.

The records of commit and abort actions contain the timestamp at which each action has done (XLOG data portion of both actions are defined in [xl_xact_commit](javascript:void(0)) and [xl_xact_abort](javascript:void(0)) respectively). Therefore, if a target time is set to the parameter *recovery_target_time*, PostgreSQL may select whether to continue recovery or not, whenever it replays XLOG record of either commit or abort action. When XLOG record of each action is replayed, PostgreSQL compares the target time and each timestamp written in the record; and if the timestamp exceed the target time, PITR process will be finished.

The function *read_backup_label* is defined in [src/backend/access/transam/xlog.c](https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xlog.c).
The structure *xl_xact_commit* and *xl_xact_abort* are defined in [src/include/access/xact.h](https://github.com/postgres/postgres/blob/master/src/include/access/xact.h).



 *Why can we use common archiving tools to make a base backup?*

Recovery process is a process to make a database cluster in a consistent state, though the cluster is inconsistent. As PITR is based on the recovery process, it can recover the database cluster even if a base backup is a bunch of inconsistent files. This is the reason why we can use common archiving tools without a file system snapshot capability or a special tool.

## 10.3. timelineId 和时间线历史文件

**Timeline** in PostgreSQL is used to distinguish between the original database cluster and the recovered ones, and is central concept of PITR. In this section, two things associated with the timeline are described: *timelineId* and *timeline history files*.

### 10.3.1. timelineId

Each timeline is given a corresponding **timelineId**, a 4-byte unsigned integer starting at 1.

An individual timelineId is assigned to each database cluster. The timelineId of original database cluster created by the initdb utility is 1. Whenever database cluster recovers, timelineId will be increased by 1. For example, in the example of the previous section, the timelineId of the cluster recovered from the original one is 2.

Figure 10.3 illustrates the PITR process from the viewpoint of the timelineId. First, we remove our current database cluster and restore the base backup made in the past, in order to go back to the starting point of recovery, and such situation is represented in the red arrow curve in the figure. Next, we start the PostgreSQL server which replays WAL data in the archive logs from the REDO point created by the *pg_start_backup* until the recovery target by tracing along the initial timeline (timelineId 1), and such situation is represented in the blue arrow line in the figure. Then, a new timelineId 2 is assigned to recovered database cluster and PostgreSQL runs on the new timeline.

**Fig. 10.3. Relation of timelineId between an original and a recovered database clusters.**

![Fig. 10.3. Relation of  timelineId between an original and a recovered database clusters.](http://www.interdb.jp/pg/img/fig-10-03.png)![img]()

As briefly mentioned in [Chapter 9](http://www.interdb.jp/pg/pgsql09.html), the first 8-digit of WAL segment filename is equal to the timelineId of the database cluster created for each segment. When the timelineId is changed, WAL segment filename will also be changed.

Focusing on WAL segment files, the recovery process will be described again. Suppose that we recover the database cluster using two archive logs ‘000000010000000000000009’ and ‘00000001000000000000000A’. The newly recovered database cluster is assigned the timelineId 2, and PostgreSQL creates the WAL segment from ‘00000002000000000000000A’. Figure 10.4 shows this situation.

**Fig. 10.4. Relation of WAL segment files between an original and a recovered database clusters.**

![Fig. 10.4. Relation of WAL segment files between an original and a recovered database clusters.](http://www.interdb.jp/pg/img/fig-10-04.png)![img]()

### 10.3.2. 时间线历史文件

When a PITR process completes, a timeline history file with names like ‘00000002.history’ is created under the archival directory and the pg_xlog subdirectory (in version 10 or later, pg_wal subdirectory). This file records which timeline it branched off from and when.

The naming rule of this file is shown in the following:

```
"8-digit new timelineId".history
```

A timeline history file contains at least one line, and each line is composed of the following three items:

- timelineId – timelineId of the archive logs used to recover.
- LSN – LSN location where the WAL segment switches happened.
- reason – human-readable explanation of why the timeline was changed.

A specific example is shown below:

```
postgres> cat /home/postgres/archivelogs/00000002.history
1	  0/A000198	before 2020-1-11 12:05:00.861324+00
```

Meaning as follows:

> The database cluster (timelineId=2) is based on the base backup whose timelineId is *1*, and is recovered in the time just *before ‘2020-1-11 12:05:00.861324+00*’ by replaying the archive logs until the *0/A000198*.

In this way, each timeline history file tells us a complete history of the individual recovered database cluster. Moreover, it is also used to PITR process itself. The detail is explained in the next section.



The timeline history file format is changed in version 9.3. Formats of versions 9.3 or later and earlier both are shown below but not in detail.

Later version 9.3:

```
timelineId	LSN	"reason"
```

Until version 9.2:

```
timelineId	WAL_segment	"reason"
```



## 10.4. 使用时间线历史文件进行时间点恢复

The timeline history file plays an important role in the second and subsequent PITR processes. By trying the second time recovery, we will explore how it is used.

Again, suppose that you made a mistake at 12:15:00 in the recovered database cluster whose timelineId is 2. In this case, to recover the database cluster, you should create a new recovery.conf shown below:

```
restore_command = 'cp /mnt/server/archivedir/%f %p'
recovery_target_time = "2020-1-11 12:15:00 GMT"
recovery_target_timeline = 2
```

The parameter *recovery_target_time* sets the time you made new mistake, and the *recovery_target_timeline* is set at '2', in order to recover along its timeline.

Restart the PostgreSQL server and enter PITR mode to recover the database at the target time along the timelineId 2. See Fig. 10.5.

**Fig. 10.5. Recover the database at 12:15:00 along the timelineId 2.**

![Fig. 10.5. Recover the database at 12:15:00 along the timelineId 2.](http://www.interdb.jp/pg/img/fig-10-05.png)![img]()

- (1) PostgreSQL reads the value of ‘*CHECKPOINT LOCATION*’ from the backup_label file.
- (2) Some values of parameters are read from the recovery.conf; in this example, *restore_command*, *recovery_target_time*, and *recovery_target_timeline*.
- (3) PostgreSQL reads the timeline history file ‘00000002.history’ which is corresponding to the value of the parameter *recovery_target_timeline*.
- (4) PostgreSQL does replaying WAL data by the following steps:
  - \1. From the REDO point to the LSN ‘0/A000198’ which is written in the 00000002.history file, PostgreSQL reads and replays WAL data of appropriate archive logs whose timelineId is 1.
  - \2. From the one after LSN ‘0/A000198’ to the one before the timestamp ‘2020-1-11 12:15:00’, PostgreSQL reads and replays WAL data (of appropriate archive logs) whose timelineId is 2.
- (5) When the recovery process completes, the current timelineId will advance to 3, and new timeline history file named *00000003.history* is created in the pg_xlog subdirectory (pg_wal subdirectory if version 10 or later) and the archival directory.
- ```
  postgres> cat /home/postgres/archivelogs/00000003.history
  1         0/A000198     before 2020-1-11 12:05:00.861324+00
  
  2         0/B000078     before 2020-1-11 12:15:00.927133+00
  ```

When you do PITR more than once, you should explicitly set a timelineId for using the appropriate timeline history file.

In this way, timeline history files are not only history logs of database cluster, but also the recovery instruction documents for PITR process.